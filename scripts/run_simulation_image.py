#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
This module contains the Segmentation class, responsible for the image
segmentation of grain-based materials (rocks, metals, etc.)
"""

import os.path

import matplotlib.pyplot as plt
import numpy as np
import skimage.io as io
from skimage import color

from grains.analysis import Analysis
from grains.meshing import OOF2, TriSkeletonGeometry
from grains.abaqus import Material, Geometry
from grains.simulation import change_domain, data_Pierre, hallpetch_constants, hallpetch, \
    hallpetch_plot
from grains.utils import decompress

# Choose whether you want to perform the simulation on the original segmented image or on the
# image obtained by extending the original segmented image
use_extended = True  # change to `False` if desired

# Use a sample image shipped with the code (https://stackoverflow.com/a/36476869/4892892)
if use_extended:
    segmented_image = 'data/1_labelimage_extended.png'
    if not os.path.isfile(segmented_image):  # extended image not yet created
        segmented_image_matrix = 'data/1_labelimage.npy'
        image_matrix = np.load(segmented_image_matrix)
        changed = change_domain(image_matrix, 4, 4, 0, 0, 0)
        nlabel = len(np.unique(changed))
        io.imsave('data/1_labelimage_extended.png',
                  color.label2rgb(changed, colors=np.random.random((nlabel, 3))))
else:
    segmented_image = 'data/1_labelimage.png'

# Isotropic linear elastic parameters are assumed to be the same for each grain
E = 210e3
nu = 0.3

# 1. Create a skeleton (geometry of the mesh) from the segmented image using OOF2D
O = OOF2()
O.read_image(segmented_image)
if use_extended:
    O.create_microstructure('microstructure_extended')
else:
    O.create_microstructure('microstructure')
O.pixel2group()
O.save_microstructure()
# As no file name was given, the script was saved as `microstructure.script`. This file is loaded
# and executed in OOF2. OOF2 will classify each image pixel to a group, based on the color of the
# segmented region (this is why it is important that every segmented region has a distinct color).
# The microstructure description is then completed, we just need to export it.
# To save storage, the file generated by OOF2 (and saved as microstructure.txt) was compressed.
if use_extended:
    decompress('data/microstructure_extended.zip', 'data')
else:
    decompress('data/microstructure.zip', 'data')
# Fetch the pixel-group relations from the generated file
if use_extended:
    O.load_pixelgroups('data/microstructure_extended.txt')
else:
    O.load_pixelgroups('data/microstructure.txt')
# Create a material for each pixel group (with the corresponding name, for simplicity)
for group in O._modules.pixelgroup:
    O.create_material('material-{0}'.format(group))
# Assign the materials to the pixel groups
O.materials2groups(O._modules.material, O._modules.pixelgroup.keys())
# Create a coarse initial skeleton composed of triangular elements
if use_extended:
    O.create_skeleton(166, 20, TriSkeletonGeometry())
else:
    O.create_skeleton(50, 50, TriSkeletonGeometry())
# The modification of the skeleton requires hand-tuning and visual checking.
# It is therefore done from the OOF GUI. See:
# https://www.ctcms.nist.gov/~langer/oof2man/RegisteredClass-SkeletonModifier.html
# For now, we can save the OOF script
if use_extended:
    O.write_script('data/microstructure_extended.script')
else:
    O.write_script('data/microstructure.script')
# The script file is imported and executed from OOF2. We then created and fine-tuned the mesh,
# which was then exported as an Abaqus input file, called `1_mesh.inp`. This file contains the
# material definitions for each grain, but no material behavior yet.

# 2. Compute the diameter of each grain
# To determine the plasticity parameters, the Hall-Petch relation is used. For that, one needs to
# obtain the diameters of the grains.
# We perform an analysis on the label image (represented as a matrix) obtained by OOF2.
# This matrix is a 2D numpy array of integers from 0 to N. Entries with the same number indicate
# pixels belonging to the same group.
labelimageOOF = O._modules.microstructure['pixelgroups']
analysis = Analysis(labelimageOOF, interactive_mode=False)
# We want to obtain the "true" diameters. For that, we determined how many mm a pixel is.
scale = 1/29.55
analysis.set_scale(scale)
# There are different definitions for the diameter. Here, we use the maximum Feret diameter
analysis.compute_properties()
d = analysis.properties["feret_diameter"]
# Some grains are actually outside the recrystallized region. They are considered homogeneous,
# modelled as tiny grains
homogeneous_region = [43, 68, 27, 13, 142, 166, 203, 170, 30, 83, 79, 87]
for i in homogeneous_region:
    d[i] = 0.03
# Uncomment the next line to plot the grains
# analysis.show_grains(grain_property='feret_diameter')
# Uncomment the next line to view the grain statistics in a table
# analysis.show_properties(gui=True)

# 3.Determine the yield stress for each grain using the Hall-Petch formula
sigma_0, k = hallpetch_constants(*data_Pierre())
sigma_y = hallpetch(sigma_0, k, d)
# Show the yield stress as a function of the grain diameter
hallpetch_plot(sigma_y, d);  plt.show()

# 4. Add elastoplastic material behavior to the Abaqus input file
material_database = Material()
if use_extended:
    material_database.read('data/1_mesh_extended.inp')
else:
    material_database.read('data/1_mesh.inp')
# Dictionary in which keys are int-s, representing the pixel groups, and the corresponding values
# are the material names
pixelgroups = O._modules.pixelgroup
for group, material in pixelgroups.items():
    material_database.add_material(material)
    material_database.add_linearelastic(material, E, nu)
    material_database.add_plastic(material, sigma_y[group], 0)
# Show in the console how the material data will look like in the Abaqus input file
material_database.show()
# Update the Abaqus input file with the elastoplastic material behavior
if use_extended:
    material_database.write('data/1_elastoplastic_extended.inp')
else:
    material_database.write('data/1_elastoplastic.inp')

# 5. Scale the geometry according to the physical dimensions
# The mesh was created on the pixel image. We want to perform the simulation in physical units.
geom = Geometry()
if use_extended:
    geom.read('data/1_elastoplastic_extended.inp')
else:
    geom.read('data/1_elastoplastic.inp')
# Shrink the original geometry and save the modified file
geom.scale(scale)
if use_extended:
    geom.write('data/1_elastoplastic_extended_physical.inp')
else:
    geom.write('data/1_elastoplastic_physical.inp')
# `1_elastoplastic_physical.inp` is the name of the file we can feed to Abaqus
